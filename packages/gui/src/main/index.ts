import { app, BrowserWindow, ipcMain, shell } from 'electron';
import path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import { ConfigManager } from './config/ConfigManager';
import { RcloneService } from './services/RcloneService';
import { RcloneConfigManager } from './services/RcloneConfigManager';
import { TransferStore } from './store/TransferStore';
import { TransferQueueManager } from './services/TransferQueueManager';
import { TransferHandlers } from './ipc/transferHandlers';
import { setupConfigHandlers } from './ipc/configHandlers';
import { setupThemeHandlers, setupNativeThemeMonitoring } from './ipc/themeHandlers';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
    app.quit();
}

console.log('Main process starting...');

// Initialize managers
const configManager = new ConfigManager();
let rcloneService: RcloneService | undefined;
let rcloneConfigManager: RcloneConfigManager | undefined;
let transferStore: TransferStore | undefined;
let transferQueueManager: TransferQueueManager | undefined;
let transferHandlers: TransferHandlers | undefined;

try {
    rcloneService = new RcloneService();
    rcloneService.getVersion().then(version => {
        console.log(`RcloneService initialized (v${version})`);
    });
} catch (e) {
    console.error('Failed to initialize RcloneService:', e);
}

try {
    rcloneConfigManager = new RcloneConfigManager();
    console.log('RcloneConfigManager initialized');
} catch (e) {
    console.error('Failed to initialize RcloneConfigManager:', e);
}

// Initialize transfer infrastructure (Phase 0)
try {
    transferStore = new TransferStore();
    console.log('TransferStore initialized');
} catch (e) {
    console.error('Failed to initialize TransferStore:', e);
}

try {
    if (rcloneService && transferStore) {
        transferQueueManager = new TransferQueueManager(rcloneService, transferStore, configManager);
        console.log('TransferQueueManager initialized');
    } else {
        throw new Error('RcloneService or TransferStore not initialized');
    }
} catch (e) {
    console.error('Failed to initialize TransferQueueManager:', e);
}

try {
    if (transferQueueManager) {
        transferHandlers = new TransferHandlers(transferQueueManager);
        transferHandlers.register();
        console.log('TransferHandlers registered');
    } else {
        throw new Error('TransferQueueManager not initialized');
    }
} catch (e) {
    console.error('Failed to register TransferHandlers:', e);
}

const createWindow = (): void => {
    console.log('Creating window...');

    // Determine icon path based on packaged state
    let iconPath: string | undefined;
    if (app.isPackaged) {
        // In production: icon is in resources folder
        iconPath = path.join(process.resourcesPath, 'build', 'icons', 'icon.ico');
    } else {
        // In development: icon is in project root
        iconPath = path.join(__dirname, '..', '..', '..', '..', 'build', 'icons', 'icon.ico');
    }

    // Create the browser window.
    const mainWindow = new BrowserWindow({
        height: 600,
        width: 800,
        titleBarStyle: 'hidden',
        icon: iconPath,
        show: false, // Don't show until ready
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });

    // Maximize and show window when ready
    mainWindow.once('ready-to-show', () => {
        mainWindow.maximize();
        mainWindow.show();
    });

    // Set main window for transfer queue manager (for IPC broadcasting)
    if (transferQueueManager) {
        transferQueueManager.setMainWindow(mainWindow);
    }

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open DevTools only in development mode
    if (!app.isPackaged) {
        mainWindow.webContents.openDevTools();
    }
};

// IPC Handlers - Window controls
ipcMain.on('window:minimize', (event) => {
    const win = BrowserWindow.fromWebContents(event.sender);
    if (win) win.minimize();
});

ipcMain.on('window:maximize', (event) => {
    const win = BrowserWindow.fromWebContents(event.sender);
    if (win) {
        if (win.isMaximized()) {
            win.unmaximize();
        } else {
            win.maximize();
        }
    }
});

ipcMain.on('window:close', (event) => {
    const win = BrowserWindow.fromWebContents(event.sender);
    if (win) win.close();
});

// Rclone IPC Handlers
ipcMain.handle('rclone:version', async () => {
    if (!rcloneService) throw new Error('RcloneService not initialized');
    return await rcloneService.getVersion();
});

ipcMain.handle('rclone:list', async (event, remote: string, remotePath: string) => {
    if (!rcloneService) throw new Error('RcloneService not initialized');
    return await rcloneService.list(remote, remotePath);
});

ipcMain.handle('rclone:getConfigPath', () => {
    if (!rcloneService) throw new Error('RcloneService not initialized');
    return rcloneService.getConfigPath();
});

// Rclone Config IPC Handlers
ipcMain.handle('rclone:listRemotes', async () => {
    if (!rcloneConfigManager) throw new Error('RcloneConfigManager not initialized');
    const remotes = await rcloneConfigManager.listRemotes();
    // Return just the names (strings) for frontend compatibility
    return remotes.map(r => r.name);
});

ipcMain.handle('rclone:deleteRemote', async (event, name: string) => {
    if (!rcloneConfigManager) throw new Error('RcloneConfigManager not initialized');
    return await rcloneConfigManager.deleteRemote(name);
});

ipcMain.handle('rclone:startOAuth', async (_event, provider: string, remoteName: string) => {
    if (!rcloneConfigManager) throw new Error('RcloneConfigManager not initialized');
    try {
        // Start OAuth - browser opens automatically via rclone authorize
        await rcloneConfigManager.startOAuth(provider, remoteName);
        return { success: true };
    } catch (err) {
        console.error('[IPC] OAuth start failed:', err);
        return { success: false, error: (err as Error).message };
    }
});

ipcMain.handle('rclone:completeOAuth', async (_event, _remoteName: string) => {
    if (!rcloneConfigManager) throw new Error('RcloneConfigManager not initialized');
    // remoteName is now stored in ConfigManager state from startOAuth
    return await rcloneConfigManager.completeOAuth();
});

ipcMain.handle('rclone:cancelOAuth', async () => {
    if (!rcloneConfigManager) throw new Error('RcloneConfigManager not initialized');
    rcloneConfigManager.cancelOAuth();
    return { success: true };
});

ipcMain.handle('rclone:getRemoteConfig', async (event, name: string) => {
    if (!rcloneConfigManager) throw new Error('RcloneConfigManager not initialized');
    return await rcloneConfigManager.getRemoteConfig(name);
});

// Rclone file operation IPC handlers
ipcMain.handle('rclone:delete', async (event, fullPath: string) => {
    if (!rcloneService) throw new Error('RcloneService not initialized');
    return await rcloneService.deleteFile(fullPath);
});

ipcMain.handle('rclone:purge', async (event, fullPath: string) => {
    if (!rcloneService) throw new Error('RcloneService not initialized');
    return await rcloneService.purge(fullPath);
});

ipcMain.handle('rclone:mkdir', async (event, fullPath: string) => {
    if (!rcloneService) throw new Error('RcloneService not initialized');
    return await rcloneService.mkdir(fullPath);
});

ipcMain.handle('rclone:rename', async (event, sourcePath: string, destPath: string) => {
    if (!rcloneService) throw new Error('RcloneService not initialized');
    return await rcloneService.rename(sourcePath, destPath);
});

// Local file system IPC handlers
ipcMain.handle('local:list', async (event, dirPath: string) => {
    try {
        // Default to user home directory if empty
        const targetPath = dirPath || os.homedir();
        const entries = await fs.promises.readdir(targetPath, { withFileTypes: true });

        const items = await Promise.all(entries.map(async (entry) => {
            const fullPath = path.join(targetPath, entry.name);
            let stats;
            try {
                stats = await fs.promises.stat(fullPath);
            } catch {
                // Skip files we can't stat (permission issues, etc.)
                return null;
            }

            return {
                Path: entry.name,
                Name: entry.name,
                Size: entry.isDirectory() ? 0 : stats.size,
                ModTime: stats.mtime.toISOString(),
                IsDir: entry.isDirectory()
            };
        }));

        // Filter out nulls (files we couldn't stat)
        return items.filter(item => item !== null);
    } catch (err) {
        console.error('[IPC] local:list error:', err);
        throw err;
    }
});

ipcMain.handle('local:getHome', () => {
    return os.homedir();
});

ipcMain.handle('local:getDrives', async () => {
    // Windows: list drive letters
    if (process.platform === 'win32') {
        const drives: string[] = [];
        for (let i = 65; i <= 90; i++) {
            const drive = String.fromCharCode(i) + ':';
            try {
                await fs.promises.access(drive + '\\');
                drives.push(drive);
            } catch {
                // Drive doesn't exist or not accessible
            }
        }
        return drives;
    }
    // Unix: return root
    return ['/'];
});

ipcMain.handle('local:delete', async (event, filePath: string, isDirectory: boolean) => {
    try {
        console.log(`[IPC] local:delete: ${filePath} (isDirectory: ${isDirectory})`);
        if (isDirectory) {
            await fs.promises.rm(filePath, { recursive: true, force: true });
        } else {
            await fs.promises.unlink(filePath);
        }
        return { success: true };
    } catch (err) {
        console.error('[IPC] local:delete error:', err);
        throw err;
    }
});

ipcMain.handle('local:mkdir', async (event, dirPath: string) => {
    try {
        console.log(`[IPC] local:mkdir: ${dirPath}`);
        await fs.promises.mkdir(dirPath, { recursive: true });
        return { success: true };
    } catch (err) {
        console.error('[IPC] local:mkdir error:', err);
        throw err;
    }
});

ipcMain.handle('local:rename', async (event, oldPath: string, newPath: string) => {
    try {
        console.log(`[IPC] local:rename: ${oldPath} -> ${newPath}`);
        await fs.promises.rename(oldPath, newPath);
        return { success: true };
    } catch (err) {
        console.error('[IPC] local:rename error:', err);
        throw err;
    }
});

// Setup IPC handlers
setupConfigHandlers(configManager, transferQueueManager);
setupThemeHandlers(configManager);

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
app.whenReady().then(() => {
    console.log('App is ready, creating window...');
    setupNativeThemeMonitoring(configManager);
    createWindow();
});

// Quit when all windows are closed, except on macOS.
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});
